# SPR-CL-TRANSACTIONAL

This coding lab covers unit "Spring Data JPA", module "Transaction Management".

## Instructions
- This program is a CRUD application that models cargo ships and containers which the ships can 
  carry. 
- Transactions can be used to group operations together and rollback changes if anything goes 
  wrong (ex: an Exception is thrown)
- Look at Lab.Service.ShipService for any TODO statements.

## Shouldn't Modify (But Look at for Context)
- Exceptions
  - Lab.Exceptions.InvalidTonnageException
  - Lab.Exceptions.NegativeWeightException
- Models
  - Lab.Model.Container
  - Lab.ModelShip
- Repository
  - Lab.Repository.ContainerRepository
  - Lab.Repository.ShipRepository
- Service
  - Lab.Service.ContainerService

## Should Modify
- Lab.Service.ShipService




package Lab.Exceptions;

/**
 * there is no need to modify this class.
 */
public class InvalidTonnageException extends Exception{
}


package Lab.Exceptions;

public class NegativeWeightException extends Exception{
}


package Lab.Model;

import com.fasterxml.jackson.annotation.JsonBackReference;
import lombok.*;

import javax.persistence.*;

/**
 * The @Entity is provided by Spring Data to convert this class into an ORM entity with a relationship to the
 * database. All other annotations have been provided by Lombok.
 *
 * Nothing in this class needs to be changed.
 */
@Entity
@Data
@ToString
@EqualsAndHashCode
@AllArgsConstructor
@NoArgsConstructor
/**
 * there is no need to modify this class.
 */
public class Container {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    public Long id;
    //    @Column annotations actually aren't necessary. all fields will be made columns by default.
    public String contents;
    public double weight;

    public Container(String contents, double weight) {
        this.contents = contents;
        this.weight = weight;
    }
}


package Lab.Model;

import com.fasterxml.jackson.annotation.JsonManagedReference;
import lombok.*;

import javax.persistence.*;
import java.util.List;

/**
 * The @Entity is provided by Spring Data to convert this class into an ORM entity with a relationship to the
 * database. All other annotations have been provided by Lombok.
 *
 * Nothing in this class needs to be changed.
 */
@Entity
@Data
@ToString
@EqualsAndHashCode
@AllArgsConstructor
@NoArgsConstructor
/**
 * there is no need to modify this class.
 */
public class Ship {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    public Long id;
    //    @Column annotations actually aren't necessary. all fields will be made columns by default.
    public String name;
    public double tonnage;

    public Ship(String name, double tonnage) {
        this.name = name;
        this.tonnage = tonnage;
    }
}


package Lab.Repository;


import Lab.Model.Container;
import org.springframework.data.jpa.repository.JpaRepository;

/**
 * there is no need to modify this class.
 */
public interface ContainerRepository extends JpaRepository<Container, Long> {
}


package Lab.Repository;

import Lab.Model.Ship;
import org.springframework.data.jpa.repository.JpaRepository;

/**
 * there is no need to modify this class.
 */
public interface ShipRepository extends JpaRepository<Ship, Long> {
}


package Lab.Service;

import Lab.Exceptions.NegativeWeightException;
import Lab.Model.Container;
import Lab.Model.Ship;
import Lab.Repository.ContainerRepository;
import Lab.Repository.ShipRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.List;

/**
 * The @Transactional annotation wraps every method in this class inside a database transaction, which is a set of
 * database statements that happen in isolation of all other database transactions, and are applied to the database in
 * an all-or-nothing manner. This means that a high volume of database transactions may transpire without having an
 * effect such as a dirty read, or reading data that has been modified in an in-progress transaction. This matters when
 * a Transaction has multiple steps. (for instance, when a single transaction should process 100 database statements
 * for purchasing items from a user's cart, we don't want Spring to make the mistake of reading from an incomplete
 * transaction, as e.g. a request for the total cost of a user's cart could return an erroneous amount, such as only
 * 50 items, if Spring happens to read an incomplete transaction.) The @Transactional annotation is actually using
 * a part of Spring known as Spring AOP (aspect-oriented-programming) to apply the transaction start & commit to every
 * method. Spring AOP actually overrides some method(s) you define (in this case, all methods of this class) to apply
 * additional code to them as Spring is loading this class as a Bean.
 *
 * You can test this by attempting to persist a list of containers where some container has a negative
 * weight, then  attempting to get all ships. No ships should be persisted if any container in the array has a negative
 * or zero weight - we're left to assume some form of unwanted user error in that case. If that happens, the Service
 * will throw an NegativeWeightException, triggering a rollback of the current transaction.
 *
 * there is no need to modify this class.
 */
@Transactional(rollbackFor = NegativeWeightException.class)
@Service
public class ContainerService {
    ContainerRepository containerRepository;
    ShipRepository shipRepository;
    @Autowired
    public ContainerService(ContainerRepository containerRepository, ShipRepository shipRepository){
        this.containerRepository = containerRepository;
        this.shipRepository = shipRepository;
    }
    /**
     * this is a bad way to save a list to the repository as you can just use the .saveAll method provided the table
     * has a CHECK constraint to check tonnage, but this gets the point across for the importance of @Transactional.
     *
     * @param id
     * @param containers transient container entities
     * @throws NegativeWeightException ships can not have negative tonnage (they'd sink), containers can not have
     *                                 negative weight (they'd fly away)
     */
    public List<Container> addListContainers(List<Container> containers) throws NegativeWeightException {
        List<Container> persistedContainers = new ArrayList<>();
        for(int i = 0; i < containers.size(); i++){
            if(containers.get(i).getWeight()<=0){
                throw new NegativeWeightException();
            }
            Container newContainer = containerRepository.save(containers.get(i));
            persistedContainers.add(newContainer);
        }
        return persistedContainers;
    }

    /**
     * @return all container entities
     */
    public List<Container> getAllContainers() {
        return containerRepository.findAll();
    }
    /**
     * @return container entities by id
     */
    public Container getContainerById(long id) {
        return containerRepository.findById(id).get();
    }
}



package Lab.Service;

import Lab.Exceptions.InvalidTonnageException;
import Lab.Model.Ship;
import Lab.Repository.ShipRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.List;

/**
 * TODO: Using the Transactional annotation, cause the methods of this Service class to roll back the current
 * database transaction when the InvalidTonnageException is thrown. This will wrap all
 * methods in this class inside of a database transaction, which will prevent incomplete updates in the event of an
 * exception being thrown. It should be assigned to rollback the transaction for some exception, hence the rollbackFor.
 * You can test this by attempting to persist a list of ships where some ship in the JSON has a negative tonnage, then
 * attempting to get all ships. No ships should be persisted if any ship in the array has a negative or zero
 * tonnage - we're left to assume some form of unwanted user error in that case.
 */
@Service
@Transactional(rollbackFor = InvalidTonnageException.class)
public class ShipService {
    ShipRepository shipRepository;
    @Autowired
    public ShipService(ShipRepository shipRepository){
        this.shipRepository = shipRepository;
    }
    /**
     * this is a bad way to save a list to the repository as you can just use the .saveAll method provided the table
     * has a CHECK constraint to check tonnage, but this gets the point across for the importance of @Transactional
     * @param ships transient ship entities
     * @throws InvalidTonnageException ships can not have negative tonnage (they'd sink)
     */
    public List<Ship> addListShips(List<Ship> ships) throws InvalidTonnageException {
        List<Ship> persistedShips = new ArrayList<>();
        for(int i = 0; i < ships.size(); i++){
            if(ships.get(i).getTonnage()<=0){
                throw new InvalidTonnageException();
            }
            persistedShips.add(shipRepository.save(ships.get(i)));
        }
        return persistedShips;
    }
    /**
     * @return all ship entities
     */
    public List<Ship> getAllShips() {
        return shipRepository.findAll();
    }
    /**
     * @return ship entity by id
     */
    public Ship getShipById(long id) {
        return shipRepository.findById(id).get();
    }
}
