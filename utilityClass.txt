Within our Java Application, we can leverage a utility class to handle the distribution 
of connectionFactory objects to other classes requiring a need to make connections and requests
of our database.

This allows for an ease of use when establishing the connection to the database by providing 
sensitive authorization credentials within a db.properties file that can be accessed by this 
utility class.
This produces a single instance of the utility.

First we must establish a db.properties file inside of our src/main/resources directory with the
following information. This is important to include within your .gitignore as we want to 
obfuscate this sensitive information.

url=jdbc:postgresql://localhost:5432/postgres
username=postgresql
password=password
Next, we will create our utility class ConnectionFactory in the util package. Pay close
attention to the comments outlining what each block of code is handling for us inside of this
class.

package com.revature.example.util;

import java.io.FileReader;
import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.Properties;

public class ConnectionFactory {

    /**
     * There are two class variables included within our ConnectionFactory 
     * utility class. First, is the single connectionFactory object itself
     * This will be passed along to any layer that will make requests to 
     * the database. Second, is the props object of the Properties Class that
     * will allow us the ability to access our db.properties to obtain our 
     * sensitive information.
     */
    private static final ConnectionFactory connectionFactory = new  ConnectionFactory(); 
    private Properties props = new Properties();

    /**
     * We include a private constructor here to make sure that there are 
     * no other possibilities to create another instance of our 
     * ConnectionFactory object. Along with this, during the construction
     * of our connectionFactory object we make sure we can load in 
     * our db.properties file, handling any potential exception thrown.
     */
    private ConnectionFactory(){ 
        try {
            props.load(new FileReader("src/main/resources/db.properties"));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Next, we must also include a static method to obtain the single
     * instance of our connectionFactory, to allow this to be accessible
     * within other classes. This way we can provide the connectionFactory
     * which can subsequently invoke the getConnection() method when we
     * need to make requests of our database.
     */
    public static ConnectionFactory getConnectionFactory() {
        return connectionFactory;
    }

    /**
     * This method provides the ability for classes to utilize the
     * getConnection() method from our Utility class and establish a
     * connection with our database that can be used to execute SQL 
     * statements through the Statement or PreparedStatement interfaces.
     * This will also check for any SQLException, incase the information
     * provided in the db.properties is incorrect.
     */
    public Connection getConnection(){
        try {
            return DriverManager.getConnection(
                props.getProperty("url"),    
                props.getProperty("username"), 
                props.getProperty("password")
            );
        } catch (SQLException e) {
            e.printStackTrace();
            return null;
        }
    }
}