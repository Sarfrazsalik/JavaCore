Runnable Interface
In Java, multithreading is achieved via the Thread class and/or the Runnable interface. java.lang.Runnable is an interface that is to be implemented by a class whose instances are intended to be executed by a thread.

Creating Threads using Runnable Interface
Create a class that implements the Runnable functional interface
implement the run() method
pass an instance of your class to a Thread constructor
call the start() method on the thread
Example:

	public class MyRunnable implements Runnable {
		@Override
		public void run() {
			System.out.println("Inside the MyRunnable class");
		}
	}
Runnable and Lambda Expressions
Because Runnable is a functional interface, we can use a lambda expression to define thread behavior inline instead of implementing the interface in a separate class. We pass a lambda expression as the Runnable type required in the Thread constructor.

Example:

public class ThreadLambda {
  public static main(String[] args) {
    Thread willRun = new Thread(() -> {
	  System.out.println("Running!");
	});
	willRun.start();
  }
}

Here are several real-world applications where the Runnable interface is commonly used:

Web Server Implementation: In web server applications, the Runnable interface is used to handle incoming client requests concurrently. Each client request is encapsulated as a Runnable task, which is then executed by a thread pool to ensure responsiveness and scalability of the server.
Background Processing: Many applications perform background processing tasks, such as batch processing, data synchronization, or periodic maintenance tasks. The Runnable interface allows you to encapsulate these tasks as separate Runnable units of work, which can be executed asynchronously or on separate threads.
Parallel Processing: In parallel processing applications, such as scientific computing or data analysis, the Runnable interface can be used to define parallelizable tasks that can be executed concurrently on multiple processor cores or nodes in a cluster.
Testing and Mocking: In unit testing and mocking frameworks, the Runnable interface can be used to define test cases or mock behaviors that need to be executed asynchronously or in parallel. This allows you to simulate concurrent execution scenarios and verify the behavior of your code under different conditions.
Overall, the Runnable interface is a versatile and widely-used component of the Java platform, providing a simple and flexible way to define and execute concurrent tasks in various types of applications and frameworks. Its usage is foundational to building responsive, scalable, and efficient software solutions that leverage the power of concurrency and parallel processing.

Steps to create a new thread using Runnable
Create a Runnable implementer and implement the run() method.
Instantiate the Thread class and pass the implementer to the Thread. Thread has a constructor which accepts Runnable instances.
Invoke the start() method of Thread instance. Start internally calls run() of the implementer. Invoking start() creates a new Thread that executes the code written in run(). Calling run() directly doesn’t create and start a new Thread, it will run in the same thread.
Example 1
public class RunnableDemo {
 
    public static void main(String[] args)
    {
        System.out.println("Main thread is- "
                        + Thread.currentThread().getName());
        Thread t1 = new Thread(new RunnableDemo().new RunnableImpl());
        t1.start();
    }
 
    private class RunnableImpl implements Runnable {
 
        public void run()
        {
            System.out.println(Thread.currentThread().getName()
                             + ", executing run() method!");
        }
    }
}
Output:

Main thread is- main
Thread-0, executing run() method!
The output shows two active threads in the program – main thread and Thread-0. The main() method is executed by the main thread but invoking the start on RunnableImpl creates and starts a new thread – Thread-0. What happens when Runnable encounters an exception? Runnable can’t throw checked exceptions but RuntimeException can be thrown from the run(). Uncaught exceptions are handled by the exception handler of the thread, and if JVM can’t handle or catch exceptions, it prints the stack trace and terminates the flow.

Example 2
import java.io.FileNotFoundException;
 
public class RunnableDemo {
 
    public static void main(String[] args)
    {
        System.out.println("Main thread is- " +
                          Thread.currentThread().getName());
        Thread t1 = new Thread(new RunnableDemo().new RunnableImpl());
        t1.start();
    }
 
    private class RunnableImpl implements Runnable {
 
        public void run()
        {
            System.out.println(Thread.currentThread().getName()
                             + ", executing run() method!");
            /**
             * Checked exception can't be thrown, Runnable must
             * handle checked exception itself.
             */
            try {
                throw new FileNotFoundException();
            }
            catch (FileNotFoundException e) {
                System.out.println("Must catch here!");
                e.printStackTrace();
            }
 
            int r = 1 / 0;
            /*
             * Below commented line is an example
             * of thrown RuntimeException.
             */
            // throw new NullPointerException();
        }
    }
}
Output:

Thread-0, executing run() method!
Must catch here!
java.io.FileNotFoundException
    at RunnableDemo$RunnableImpl.run(RunnableDemo.java:25)
    at java.lang.Thread.run(Thread.java:745)
Exception in thread "Thread-0" java.lang.ArithmeticException: / by zero
    at RunnableDemo$RunnableImpl.run(RunnableDemo.java:31)
    at java.lang.Thread.run(Thread.java:745)
The output shows that Runnable can’t throw checked exceptions, like FileNotFoundException, to the callers. It must handle checked exceptions in the run() method but RuntimeExceptions (thrown or auto-generated) are handled by the JVM automatically.

Exercise (Optional)
Write a program to find the number in the range 1 to 100000 that has the largest number of divisors. By using threads, your program will take less time to do the computation when it is run on a multiprocessor computer. At the end of the program, output the elapsed time, the integer that has the largest number of divisors, and the number of divisors that it has. For this exercise, you should simply divide up the problem into parts and create one thread to do each part.

