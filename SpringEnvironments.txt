An application environment refers to the context in which a software application operates, such as the configuration settings that define the behavior application when it runs. Spring Boot allows us to externalize configuration so we can work with the same application code in different environments. We can use external sources such as properties files, YAML files, environment variables, command-line arguments, and more, rather than hardcoding configuration values directly into the application code.

Configuration Annotations
Spring introduces the new @PropertySource annotation as a convenient mechanism for adding property sources to the environment.

We can use this annotation in conjunction with the @Configuration:

@Configuration
@PropertySource("classpath:application2.properties")
public class RevatureApplication {
    //.....
}
Another very useful way to register a new properties file is using a placeholder, which allows us to dynamically select the right file at runtime:

@PropertySource({ 
  "classpath:persistence-${envTarget:mysql}.properties"
})
Property values can be injected directly into your beans using the @Value annotation, accessed via Springâ€™s Environment abstraction or bound to structured objects via @ConfigurationProperties.

Injecting a property with the @Value annotation:

@Value( "${jdbc.url}" )
private String jdbcUrl;


Externalized configuration provides several benefits:

Flexibility: Externalized configuration allows you to change configuration settings without modifying the application code. This makes it easier to customize the behavior of your application for different environments (e.g., development, testing, production) or specific deployments.
Security: Externalizing sensitive configuration properties (such as database credentials, API keys, and encryption keys) to external sources helps improve security by reducing the risk of exposing sensitive information in code repositories or production environments.
Portability: By separating configuration from code, you can deploy the same application binary to different environments without modifications. Configuration can be customized for each environment using external sources, making deployments more consistent and predictable.
Ease of Management: Managing configuration settings in external files or environment variables simplifies configuration management tasks. Configuration files can be version-controlled, documented, and managed separately from the application code, making it easier to track changes and collaborate with team members.



Below is an example of running a project with different configurations.

Let's say we have the below project. Notice there is an application.yaml file and an application2.yaml file in our src/main/resources directory. This file will be auto-detected by Spring Boot. We can refer to this file in our application to work with the properties from within it.

yml

Let's say the following code is within the application.yml file:

server.port = 8005
spring.jpa.show-sql = true
spring.datasource.url= jdbc:mysql://localhost:3306/revatureDB
spring.datasource.username=root
spring.datasource.password=root
spring.jpa.hibernate.ddl-auto=update
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
management.security.enabled=false
We can add the @PropertySource annotation as shown below to our Driver class:

package com.revature;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.PropertySource;

@SpringBootApplication
@PropertySource("classpath:application.yml")
public class RevatureApplication {

    public static void main(String[] args) {
        SpringApplication.run(RevatureApplication.class, args);
    }
}
We see the application start up just fine:

env

Similarly, we add different configurations in the application2.yml file:

server.port = 8009
spring.jpa.show-sql = true
spring.datasource.url= jdbc:mysql://localhost:3306/revatureDB1
spring.datasource.username=root
spring.datasource.password=root
spring.jpa.hibernate.ddl-auto=update
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
management.security.enabled=false
We can then run the program using this alternate file:

package com.revature;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.PropertySource;

@SpringBootApplication
@PropertySource("classpath:application2.yml")
public class RevatureApplication {

    public static void main(String[] args) {
        SpringApplication.run(RevatureApplication.class, args);
    }
}
Output:

envn

Just now we have executed the same application with two different configuration files. This is how we can use the different configuration files without touching our application logic.

