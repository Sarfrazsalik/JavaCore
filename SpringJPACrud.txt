# SPR-CL-JPACRUD

This coding lab covers unit "Spring Data JPA", module "Spring Data Repositories".

## Instructions
- This project is an example of a Grocery Application. It contains CRUD operations that let us create/edit/delete stores and grocery items. 
- The service classes perform the business logic of the application and leverage the Repository layer to interact with the database.
- Your main goal will be able to fill out methods of the Store Service.
- Look for @TODO statements and fill out the methods accordingly.

## Shouldn't Modify (But Look at for Context)
- Lab.Application
- Models
  - Lab.Model.Grocery
  - Lab.Model.Store
- Repository
  - Lab.Repository.GroceryRepository
  - Lab.Repository.StoreRepository
- Lab.Service.GroceryService
- Test files

## Should Modify
- Lab.Service.StoreService


package Lab.Model;

import lombok.*;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

/**
 * JPA Entity intended to model a grocery item such as Milk, Bread, etc.
 *
 * For the sake of brevity, Lombok is also used to automatically generate boilerplate code.
 */
@Entity
@ToString
@EqualsAndHashCode
@NoArgsConstructor
@AllArgsConstructor
@Data
public class Grocery {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;
    private String name;

    public Grocery(String name) {
        this.name = name;
    }
}


package Lab.Model;

import lombok.*;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

/**
 * JPA Entity intended to model a grocery store.
 *
 * For the sake of brevity, Lombok is also used to automatically generate boilerplate code.
 */
@Entity
@ToString
@EqualsAndHashCode
@NoArgsConstructor
@AllArgsConstructor
@Data
public class Store {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;
    private String name;
    private String address;

    public Store(String name, String address) {
        this.name = name;
        this.address = address;
    }
}


package Lab.Service;

import Lab.Model.Grocery;
import Lab.Repository.GroceryRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;

@Service
public class GroceryService {
    GroceryRepository groceryRepository;
    @Autowired
    public GroceryService(GroceryRepository groceryRepository){
        this.groceryRepository = groceryRepository;
    }

    /**
     * Given a brand new transient grocery (meaning, no such grocery exists yet in the database),
     * persist the grocery to the database (create a new database record for the grocery entity.)
     */
    public Grocery persistGrocery(Grocery grocery){
        return groceryRepository.save(grocery);
    }
    /**
     * finaAll() will return all grocery entities stored in the DB table.
     * @return all Grocery entities.
     */
    public List<Grocery> getAllGroceries(){
        return groceryRepository.findAll();
    }

    /**
     * Because fingById() returns a type of Optional<Grocery>, we also need to apply .get() to convert the
     * Optional<Grocery> to Grocery. Optionals help the developer to avoid null pointer exceptions.
     * @param id the id of the Grocery entity.
     * @return Grocery entity
     */
    public Grocery getGroceryById(long id){
        //findById returns a type Optional<Grocery>. This helps the developer avoid null pointer
        //exceptions. We can use the method .get() to convert an Optional<Grocery> to Grocery.
        Optional<Grocery> optionalGrocery = groceryRepository.findById(id);
        if(optionalGrocery.isPresent()){
            return optionalGrocery.get();
        }else{
            return null;
        }
    }
    /**
     * Delete a grocery entity of a certain id.
     * @param id
     * @return
     */
    public void deleteGrocery(long id){
        groceryRepository.deleteById(id);
    }
    /**
     * Given a groceru ID, overwrite the contents of the grocery entity.
     * @param id
     * @return
     */
    public void updateGrocery(long id, Grocery replacement){
        //findById returns a type Optional<Grocery>. This helps the developer avoid null pointer
        //exceptions. We can use the method .get() to convert an Optional<Grocery> to Grocery.
        Optional<Grocery> optionalGrocery = groceryRepository.findById(id);
        if(optionalGrocery.isPresent()){
            Grocery grocery = optionalGrocery.get();
            grocery.setName(replacement.getName());
            groceryRepository.save(grocery);
        }

    }
}

package Lab.Service;

import Lab.Model.Store;
import Lab.Repository.StoreRepository;
import io.micrometer.core.instrument.Meter.Id;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;

@Service
public class StoreService {
    StoreRepository storeRepository;
    @Autowired
    public StoreService(StoreRepository storeRepository){
        this.storeRepository = storeRepository;
    }
    /**
     * TODO: given a transient store, persist the store and return it.
     * @param store a transient store
     * @return the persisted store
     */
    public Store persistStore(Store store){
        return storeRepository.save(store);
    }
    /**
     * TODO: get all store entities
     * @return all store entities
     */
    public List<Store> getAllStores(){
        return storeRepository.findAll();
    }
    /**
     * TODO: given an id of a store, return the store.
     *
     * @param id id of store entity
     * @return a store entity
     */
    public Store getStoreById(long id){
        return storeRepository.findById(id).orElse(null);
    }
    /**
     * TODO: given an id of an existing store, delete the store
     */
    public void deleteStore(long id){
       storeRepository.deleteById(id);
    }
    /**
     * TODO: given an id and some replacement data for a store, overwrite the data of an existing store,
     * and return the updated store.
     * @return the updated store entity
     */
    public Store updateStore(long id, Store replacement){
        return storeRepository.findById(id)
        .map(existingStore -> {
            existingStore.setName(replacement.getName());
            return storeRepository.save(existingStore);
        })
        .orElse(null);
}


}
